#!/usr/bin/python

import getopt, os, sys, re
import tempfile, traceback
import xml.dom.minidom
import socket, smtplib

config_dir = '/etc/labackup'
config_ext = '.cfg'
log = ''

VERSION = "0.0.1"

######################################################################
# Miscellaneous
######################################################################

def send(msg):
    print msg
    sys.stdout.flush()

def debug(msg):
    global log
    print msg
    log += msg + '\n'
    sys.stdout.flush()

def warn(msg):
    global log
    print 'WARN:', msg
    log += 'WARN: ' + msg + '\n'
    sys.stdout.flush()

def error(msg):
    global log
    print 'ERROR:', msg
    log += 'ERROR: ' + msg + '\n'
    sys.stdout.flush()

######################################################################
# Configuration file parser
######################################################################

class ConfigException (Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def parse_dump(dump_el):
    type = dump_el.getAttribute('type')
    if not type:
        raise ConfigException('You need to specify the database type')
    if type not in ('postgres', 'postgresql', 'pgsql', 'mysql'):
        raise ConfigException('Invalid database type: ' + type)
    db = dump_el.getAttribute('db')
    if not db:
        raise ConfigException('You need to specify the database name')
    user = dump_el.getAttribute('user')
    dbuser = dump_el.getAttribute('dbuser')
    file = dump_el.getAttribute('file')
    if not file:
        raise ConfigException('You need to specify where the database should be dumped')
    cleanup = dump_el.getAttribute('cleanup')
    return { 'type' : type, 'db' : db, 'user' : user, 'dbuser' : dbuser,
             'file' : file, 'cleanup' : cleanup }

def parse_snap(snap_el):
    device = snap_el.getAttribute('device')
    if not device:
        raise ConfigException('Please specify the device to be snapshot')
    if device.rfind('/') == -1 or device.endswith('/'):
        raise ConfigException('The device name seems incorrect: ' + device)
    size = snap_el.getAttribute('size')
    if not size:
        raise ConfigException('Please specify the size for the snapshot')
    return { 'device' : device, 'size' : size }

def parse_clude(clude_el):
    path = clude_el.getAttribute('path')
    path = path.replace('*', '\*').replace('?', '\?')
    path = path.replace('[', '\[').replace(']', '\]')
    glob = clude_el.getAttribute('glob')
    regexp = clude_el.getAttribute('regexp')
    if not path and not glob and not regexp:
        raise ConfigException('Empty ' + clude_el.tagName)
    return { 'type' : clude_el.tagName, 'path' : path, 'glob' : glob, 'regexp' : regexp }

def parse_config(backup_el, filename):
    if backup_el.tagName != 'backup':
        raise ConfigException('Invalid config file, the top level element must be <backup>')
    id = backup_el.getAttribute('id')
    if not id: id = filename

    host_el = backup_el.getElementsByTagName('host')
    host = host_el[0].getAttribute('name')
    if not host: host = 'localhost'
    user = host_el[0].getAttribute('user')
    if not user: user = 'root'
    key = host_el[0].getAttribute('key')
    key2 = host_el[0].getAttribute('key2')

    dir_el = backup_el.getElementsByTagName('dir')
    if len(dir_el) > 0:
        dir = dir_el[0].getAttribute('path')
    else: dir = None
    if not dir: dir = './' + id

    setup_el = backup_el.getElementsByTagName('setup')
    dumps = []
    snaps = []
    if len(setup_el) > 0:
        dump_els = setup_el[0].getElementsByTagName('dump')
        for dump_el in dump_els:
            dumps.append(parse_dump(dump_el))
        snap_els = setup_el[0].getElementsByTagName('snapshot')
        for snap_el in snap_els:
            snaps.append(parse_snap(snap_el))

    data_el = backup_el.getElementsByTagName('data')

    child_els = data_el[0].childNodes
    cludes = []
    for child_el in child_els:
        if child_el.nodeType != child_el.ELEMENT_NODE:
            continue
        if child_el.tagName not in ('include', 'exclude'):
            continue
        cludes.append(parse_clude(child_el))
    cludes.append({ 'type' : 'exclude', 'path' : '', 'glob' : '', 'regexp' : '.*' })

    return { 'id': id, 'host' : host, 'user' : user, 'key' : key, 'key2' : key2,
             'dir' : dir, 'dumps' : dumps, 'snaps' : snaps, 'cludes' : cludes}

######################################################################
# DB and SNAPSHOT support
#   setup methods can raise exception to signal errors
#   teardown methods must succeed and cleanup the state
######################################################################

def do_client_dbdump(cfg):
    debug('Doing DB dumps')
    for dump in cfg['dumps']:
        type = dump['type']
        if type in ('postgres', 'postgresql', 'pgsql'):
            args = ['pg_dump', '-f', dump['file']]
            if dump['dbuser']:
                args.extend(['-U', dump['dbuser']])
            args.append(dump['db'])
        elif type in ('mysql'):
            args = ['mysqldump', '-r', dump['file']]
            if dump['dbuser']:
                args.extend(['-u', dump['dbuser']])
            args.append(dump['db'])
        else:
            warn('Invalid database type: ' + type)
            continue
        debug('Run [' + ' '.join(args) + ']')
        if dump['user']:
            cmd = ' '.join(args)   # FIXME: we need proper quoting
            args = [ 'su', '-c', cmd, '-', dump['user'] ]
        ec = os.spawnvp(os.P_WAIT, args[0], args)
        if ec:
            warn('Can not dump the database: ' + dump['db'])

def do_client_dbdump_teardown(cfg):
    debug('Tear down DB dumps')
    for dump in cfg['dumps']:
        if dump['cleanup'] != 'true':
            continue
        try:
            os.remove(dump['file'])
        except Exception, e:
            warn('Unable to remove dump file: %s for database %s because: %s' %
                 (dump['file'], dump['db'], e))

def gather_lvm_information(device):
    device = device.replace('/mapper','').replace('-','/')
    group = device.split('/')[-2]
    volume = device.split('/')[-1]
    (cin, cout) = os.popen4('mount')
    lines = cout.readlines()
    cout.close()
    cin.close()
    for line in lines:
        if line.startswith('/dev/mapper/' + group + '-' + volume + ' '):
            return (group, volume, line.split(' ')[2], line.split(' ')[4])
        elif line.startswith('/dev/' + group + '/' + volume + ' '):
            return (group, volume, line.split(' ')[2], line.split(' ')[4])
    return (None, None, None, None)

def do_client_snap(cfg, bdir):
    debug('Doing FS snapshots')
    for snap in cfg['snaps']:
        (group, volume, mp, mt) = gather_lvm_information(snap['device'])
        if not mp:
            warn('Cannot find the mountpoint for: ' + snap['device'])
            continue
        args = ['lvcreate', '-s', '-L', snap['size'], '-n',
                volume + '_snap',
                '/dev/' + group + '/' + volume]
        debug('Run [' + ' '.join(args) + ']')
        ec = os.spawnvp(os.P_WAIT, args[0], args)
        if ec:
            warn('Can not snapshot the device: ' + snap['device'])
            continue
        # no need to mkdir since the mountpoint already exists
        args = ['mount', '-t', mt,
                '/dev/' + group + '/' + volume + '_snap', bdir + mp]
        debug('Run [' + ' '.join(args) + ']')
        ec = os.spawnvp(os.P_WAIT, args[0], args)
        if ec:
            warn('Can not mount the snapshot: ' + snap['device'])
            args = ['lvremove', '-f', '/dev/' + group + '/' + volume + '_snap']
            ret = os.spawnvp(os.P_WAIT, args[0], args)
            if ret:
                warn('Can not tear down snapshot: ' + snap['device'])

def do_client_snap_teardown(cfg, bdir):
    debug('Tear down FS snapshots dumps')
    for snap in cfg['snaps']:
        (group, volume, mp, mt) = gather_lvm_information(snap['device'])
        if not mp:
            warn('Can not find the mountpoint for: ' + snap['device'])
            continue
        args = ['umount', bdir + mp]
        debug('Run [' + ' '.join(args) + ']')
        ret = os.spawnvp(os.P_WAIT, args[0], args)
        if ret:
            warn('umount %s%s returned %s' % (bdir, mp, ret))
        args = ['lvremove', '-f', '/dev/' + group + '/' + volume + '_snap']
        debug('Run [' + ' '.join(args) + ']')
        ret = os.spawnvp(os.P_WAIT, args[0], args)
        if ret:
            warn('Can not tear down snapshot: ' + snap['device'])

######################################################################
# Client implementation
######################################################################

def do_client_config(cmd):
    cfgStr = ''

    cnt_str = cmd[cmd.index(':') + 1:].strip()
    for i in xrange(int(cnt_str)):
        line = sys.stdin.readline()
        if not line: raise ConfigException('Unexpected end of file')
        cfgStr += line

    dom = xml.dom.minidom.parseString(cfgStr)
    try:
        cfg = parse_config(dom.documentElement, None)
        send('OK')
        return cfg
    finally:
        dom.unlink()

def do_client_setup(cfg, bdir):
    debug('Do setup of %s in %s' % (cfg['host'], bdir))
    if bdir:
        args = ['mount', '--rbind', '/', bdir]
        debug('Run: [' + ' '.join(args) + ']')
        ret = os.spawnvp(os.P_WAIT, args[0], args)
        if ret:
            warn('mount --rbind failed with %d, snapshotting will be disabled' % ret)
            bdir = None

    do_client_dbdump(cfg)
    if bdir:
        do_client_snap(cfg, bdir)

    send('OK')

def do_client_cleanup(cfg, bdir):
    debug('Do cleanup of %s in %s' % (cfg['host'], bdir))
    if bdir: do_client_snap_teardown(cfg, bdir)
    do_client_dbdump_teardown(cfg)

    if bdir:
        args = ['umount', '-l', bdir]
        debug('Run: [' + ' '.join(args) + ']')
        ret = os.spawnvp(os.P_WAIT, args[0], args)
        if ret:
            warn('Failed to unmount: ' + bdir)
        else:
            try:
                os.rmdir(bdir)
            except Exception, e:
                warn('Unable to remove: ' + bdir)

    send('OK')

def do_client():
    cleanup = True
    try:
        while True:
            try:
                line = sys.stdin.readline()
                if line.startswith('CONFIG'):
                    cfg = do_client_config(line)
                elif line.startswith('BDIR'):
                    bdir = tempfile.mkdtemp("", "lbc")
                    if not bdir.endswith('/'): bdir += '/'
                    send('OK ' + bdir)
                elif line.startswith('SETUP'):
                    do_client_setup(cfg, line[5:].strip())
                elif line.startswith('CLEANUP'):
                    dir = line[7:].strip()
                    cleanup = (dir == bdir)
                    do_client_cleanup(cfg, dir)
                elif not line:
                    break
                else:
                    send('ERROR Unknown command: ' + line)
                    break
            except Exception, e:
                traceback.print_exc(file=sys.stdout)
                send('ERROR ' + e)
    finally:
        if cleanup:
            do_client_cleanup(cfg, bdir)


######################################################################
# Server implementation
######################################################################

def do_server_getanswer(cout):
    while True:
        line = cout.readline()
        if line.startswith('OK'):
            return line[2:-1].strip()
        elif line.startswith('ERROR'):
            raise Exception(line[5:])
        elif not line:
            raise Exception('client died unexpectedly')
        else:
            debug('lbc: ' + line[:-1])

def do_server_rdiff(cfg, bdir):
    args = ['rdiff-backup']

    schema = 'ssh -C'
    if cfg['key2']:
        schema += ' -i ' + cfg['key2']
    schema += ' %s rdiff-backup --server'
    args.extend(['--remote-schema', schema])

    #args.extend([ '-v', '6'])
    for clude in cfg['cludes']:
        opt = '--' + clude['type']
        if clude['path']:
            args.extend([opt, bdir + clude['path']])
        if clude['glob']:
            args.extend([opt, bdir + clude['glob']])
        if clude['regexp']:
            args.extend([opt + '-regexp', bdir + clude['regexp']])

    args.extend([cfg['user'] + '@' + cfg['host'] + '::' + bdir, cfg['dir']])
    debug('lbs: Run [' + ' '.join(args) + ']')
    ret = os.spawnvp(os.P_WAIT, args[0], args)
    if ret:
        raise Exception('rdiff-backup returned %d' % ret)

def do_server(email, smtp, cfgs):
    # First compute the set of configuration files
    cfgfiles = []
    for cfg in cfgs:
        if os.path.isdir(cfg):
            for ent in os.listdir(cfg):
                if not ent.endswith(config_ext):
                    continue
                filepath = os.path.join(cfg, ent)
                if not os.path.isfile(filepath):
                    continue
                cfgfiles.append(filepath)
        elif os.path.isfile(cfg):
            cfgfiles.append(cfg)
        else:
            print >> sys.stderr, 'Inaccessible configuration, ignoring:', cfg

    for filepath in cfgfiles:
        filename = os.path.splitext(os.path.basename(filepath))[0]

        cfg_file = open(filepath)
        cfg_str = cfg_file.read()
        cfg_file.close()

        dom = xml.dom.minidom.parseString(cfg_str)
        try:
            cfg = parse_config(dom.documentElement, filename)
        finally:
            dom.unlink()

        debug('lbs: Do server backup [' + cfg['id'] + ']')

        ssh = 'ssh -T'
        if cfg['key']:
            ssh += ' -i ' + cfg['key']
        ssh += ' -l ' + cfg['user'] + ' ' + cfg['host']
        debug('lbs: Run [' + ssh + ']')

        (cin, cout) = os.popen4(ssh)

        cin.write('CONFIG: %d\n' % (len(cfg_str.splitlines())))
        cin.write(cfg_str)
        cin.flush()
        do_server_getanswer(cout)

        cin.write('BDIR\n')
        cin.flush()
        bdir = do_server_getanswer(cout)

        try:
            cin.write('SETUP ' + bdir + '\n')
            cin.flush()
            do_server_getanswer(cout)

            do_server_rdiff(cfg, bdir)
        finally:
            cin.write('CLEANUP ' + bdir + '\n')
            cin.flush()
            do_server_getanswer(cout)

        debug('lbs: Server backup [' + cfg['id'] + '] done')
    debug('lbs: Server backup done')

    if email:
        global log
        log = 'From: LaBackup@' + socket.gethostname() + \
              '\r\nTo: ' + email + \
              '\r\nSubject: LaBackup results on ' + socket.gethostname() + \
              '\r\n\r\n' + log
        server = smtplib.SMTP(smtp)
        server.sendmail('LaBackup@' + socket.gethostname(),
                        email,
                        log)
        server.quit()

######################################################################
# Main routine
######################################################################

def usage():
    print 'usage: %s [options]' % (sys.argv[0])
    print
    print 'options:'
    print '-C, --cfg=<file|dir>  use the given configuration file/directory'
    print '-e, --email=EMAIL     send results by email'
    print '-h, --help            show this help message and exit'
    print '-m, --smtp=SMTP       SMTP server to use when sending mails (default localhost)'
    print '-s, --server          launch in server mode (default)'
    print '-c, --client          launch in client mode'
    print '-v, --version         show the version number'

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'C:e:hm:scv', ['cfg=', 'email=', 'help', 'smtp=', 'server', 'client', 'version'])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    mode = 'server'
    email = None
    smtp = 'localhost'
    cfgs = []
    for o, a in opts:
        if o in ('-C', '--cfg'):
            cfgs.append(a)
        elif o in ('-e', '--email'):
            email = a
        elif o in ('-h', '--help'):
            usage()
            sys.exit()
        elif o in ('-m', '--smtp'):
            smtp = a
        elif o in ('-s', '--server'):
            mode = 'server'
        elif o in ('-c', '--client'):
            mode = 'client'
        elif o in ('-v', '--version'):
            print 'LaBackup', VERSION
            return

    if len(cfgs) == 0:
        cfgs.append(config_dir)

    if mode == 'server':
        do_server(email, smtp, cfgs)
    else:
        do_client()

if __name__ == '__main__':
    main()

# vim: et ts=8 sw=4 sts=4
