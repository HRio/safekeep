#!/usr/bin/python

import getopt, os, sys, re, traceback
import xml.dom.minidom
import popen2, tempfile

config_dir = './etc/labackup'

######################################################################
# Miscellaneous
######################################################################

def debug(msg):
    print msg
    sys.stdout.flush()
    pass

######################################################################
# Configuration file parser
######################################################################

def parse_dump(dump_el):
    type = dump_el.getAttribute('type')
    db = dump_el.getAttribute('db')
    user = dump_el.getAttribute('user')
    file = dump_el.getAttribute('file')
    cleanup = dump_el.getAttribute('cleanup')
    assert type and db and file
    return { 'type' : type, 'db' : db, 'user' : user,
             'file' : file, 'cleanup' : cleanup }

def parse_snap(snap_el):
    device = snap_el.getAttribute('device')
    assert device
    assert device.rfind('/') != -1 and not device.endswith('/')
    size = snap_el.getAttribute('size')
    assert size
    return { 'device' : device, 'size' : size }

def parse_clude(clude_el):
    path = clude_el.getAttribute('path')
    path = path.replace('*', '\*').replace('?', '\?')
    path = path.replace('[', '\[').replace(']', '\]')
    glob = clude_el.getAttribute('glob')
    regexp = clude_el.getAttribute('regexp')
    assert path or glob or regexp
    return { 'type' : clude_el.tagName, 'path' : path, 'glob' : glob, 'regexp' : regexp }

def parse_config(backup_el):
    assert backup_el.tagName == 'backup'
    id = backup_el.getAttribute('id')
    assert id

    host_el = backup_el.getElementsByTagName('host')
    host = host_el[0].getAttribute('name')
    if not host: host = 'localhost'
    user = host_el[0].getAttribute('user')
    if not user: user = 'root'
    key = host_el[0].getAttribute('key')
    key2 = host_el[0].getAttribute('key2')

    dir_el = backup_el.getElementsByTagName('dir')
    if len(dir_el) > 0:
        dir = dir_el[0].getAttribute('path')
    else: dir = None
    if not dir: dir = './' + id

    setup_el = backup_el.getElementsByTagName('setup')
    dumps = []
    snaps = []
    if len(setup_el) > 0:
        dump_els = setup_el[0].getElementsByTagName('dump')
        for dump_el in dump_els:
            dumps.append(parse_dump(dump_el))
        snap_els = setup_el[0].getElementsByTagName('snapshot')
        for snap_el in snap_els:
            snaps.append(parse_snap(snap_el))

    data_el = backup_el.getElementsByTagName('data')

    child_els = data_el[0].childNodes
    cludes = []
    for child_el in child_els:
        if child_el.nodeType != child_el.ELEMENT_NODE:
            continue
        if child_el.tagName not in ('include', 'exclude'):
            continue
        cludes.append(parse_clude(child_el))
    cludes.append({ 'type' : 'exclude', 'path' : '', 'glob' : '', 'regexp' : '.*' })

    return { 'id': id, 'host' : host, 'user' : user, 'key' : key, 'key2' : key2,
             'dir' : dir, 'dumps' : dumps, 'snaps' : snaps, 'cludes' : cludes}

######################################################################
# DB and SNAPSHOT support
#   setup methods can raise exception to signal errors
#   teardown methods must succeed and cleanup the state
######################################################################

def do_client_dbdump(cfg):
    debug('Doing DB dumps')
    for dump in cfg['dumps']:
        type = dump['type']
        if type in ('postgres', 'postgresql', 'pgsql'):
            args = ['pg_dump', '-f', dump['file']]
            if dump['user']:
                args.extend(['-U', dump['user']])
            args.append(dump['db'])
        elif type in ('mysql'):
            args = ['mysqldump', '-r', dump['file']]
            if dump['user']:
                args.extend(['-u', dump['user']])
            args.append(dump['db'])
        else:
            raise Exception('Invalid database type: ' + type)
        debug('Run [' + ' '.join(args) + ']')
        ec = os.spawnvp(os.P_WAIT, args[0], args)
        if ec:
            raise Exception('Can not dump the database: ' + dump['db'])

def do_client_dbdump_teardown(cfg):
    debug('Tear down DB dumps')
    for dump in cfg['dumps']:
        if dump['cleanup'] != 'true':
            continue
        try:
            os.remove(dump['file'])
        except Exception, e:
            print 'Unable to remove', dump['file'], e

def snap_dev_to_mp(device):
    device = device.strip() + ' '
    (cout, cin) = popen2.popen4('mount')
    lines = cout.readlines()
    cout.close()
    cin.close()
    for line in lines:
        if line.startswith(device):
            return (line.split(' ')[1], line.split(' ')[3])
    return (None, None)

def do_client_snap(cfg, bdir):
    debug('Doing FS snapshots')
    for snap in cfg['snaps']:
        snapdir = snap['device'][:snap['device'].rfind('/')]
        snapname = snap['device'][snap['device'].rfind('/') + 1 :] + '-snap'
        (mp, mt) = snap_dev_to_mp(snap['device'])
        if not mp:
            raise Exception('Cannot find the mountpoint for: ' + snap['device'])

        args = ['lvcreate', '-s', '-L', snap['size'], '-n', snapname, snap['device']]
        debug('Run [' + ' '.join(args) + ']')
        ec = os.spawnvp(os.P_WAIT, args[0], args)
        if ec:
            raise Exception('Can not snapshot the device: ' + snap['device'])
        # no need to mkdir since the mountpoint already exists
        args = ['mount', '-t', mt, snapdir + '/' + snapname, bdir + mp ]
        debug('Run [' + ' '.join(args) + ']')
        ec = os.spawnvp(os.P_WAIT, args[0], args)
        if ec:
            raise Exception('Can not snapshot the device: ' + snap['device'])

def do_client_snap_teardown(cfg, bdir):
    debug('Tear down FS snapshots dumps')
    for snap in cfg['snaps']:
        snapdir = snap['device'][:snap['device'].rfind('/')]
        snapname = snap['device'][snap['device'].rfind('/') + 1 :] + '-snap'
        (mp, mt) = snap_dev_to_mp(snap['device'])
        if not mp:
            print 'Cannot find the mountpoint for: ' + snap['device']
            return
        args = ['umount', bdir + mp ]
        debug('Run [' + ' '.join(args) + ']')
        ret = os.spawnvp(os.P_WAIT, args[0], args)
        if ret:
            print 'umount', bdir + mp, 'returned', ret
        args = ['lvremove', snapdir + '/' + snapname ]
        debug('Run [' + ' '.join(args) + ']')
        ret = os.spawnvp(os.P_WAIT, args[0], args)
        if ret:
            print 'lvremove', snapdir + '/' + snapname, 'returned', ret

######################################################################
# Client implementation
######################################################################

def do_client_config(cmd):
    cfgStr = ''

    cnt_str = cmd[cmd.index(':') + 1:].strip()
    for i in xrange(int(cnt_str)):
        line = sys.stdin.readline()
        if not line: raise Exception('Unexpected end of file')
        cfgStr += line

    dom = xml.dom.minidom.parseString(cfgStr)
    try:
        cfg = parse_config(dom.documentElement)
        print 'OK'
        sys.stdout.flush()
        return cfg
    finally:
        dom.unlink()

def do_client_setup(cfg, bdir):
    debug('Do setup of ' + cfg['host'] + ' in ' + bdir)

    args = ['mount', '--rbind', '/', bdir]
    debug('Run: [' + ' '.join(args) + ']')
    ret = os.spawnvp(os.P_WAIT, args[0], args)
    if ret:
        raise Exception('mount --rbind returned %d' % ret)

    do_client_dbdump(cfg)
    do_client_snap(cfg, bdir)
    print 'OK'
    sys.stdout.flush()

def do_client_cleanup(cfg, bdir):
    debug('Do cleanup of ' + cfg['host'] + ' in ' + bdir)
    do_client_snap_teardown(cfg, bdir)
    do_client_dbdump_teardown(cfg)

    args = ['umount', '-l', bdir]
    debug('Run: [' + ' '.join(args) + ']')
    ret = os.spawnvp(os.P_WAIT, args[0], args)
    if ret:
        print 'umount --rbind returned', ret

    try:
        os.rmdir(bdir)
    except Exception, e:
        print 'Unable to remove ', bdir, e
    print 'OK'
    sys.stdout.flush()

def do_client():
    while True:
        try:
            line = sys.stdin.readline()
            if line.startswith('CONFIG'):
                cfg = do_client_config(line)
            elif line.startswith('BDIR'):
                bdir = tempfile.mkdtemp("", "lbc")
                if not bdir.endswith('/'): bdir += '/'
                print 'OK ' + bdir
                sys.stdout.flush()
            elif line.startswith('SETUP'):
                do_client_setup(cfg, line[5:].strip())
            elif line.startswith('CLEANUP'):
                do_client_cleanup(cfg, line[7:].strip())
            elif not line:
                break
            else:
                raise Exception('Unknown command: ' + line)
        except Exception, e:
            traceback.print_exc(file=sys.stdout)
            print 'ERROR', e
            sys.stdout.flush()

######################################################################
# Server implementation
######################################################################

def do_server_getanswer(cout):
    while True:
        line = cout.readline()
        if line.startswith('OK'):
            return line[2:-1].strip()
        elif line.startswith('ERROR'):
            raise Exception(line[5:])
        elif not line:
            raise Exception('client died unexpectedly')
        else:
            debug('lbc: ' + line[:-1])

def do_server_rdiff(cfg, bdir):
    args = ['rdiff-backup']

    schema = 'ssh -C'
    if cfg['key2']:
        schema += ' -i ' + cfg['key2']
    schema += ' %s rdiff-backup --server'
    args.extend(['--remote-schema', schema])

    #args.extend([ '-v', '6'])
    for clude in cfg['cludes']:
        opt = '--' + clude['type']
        if clude['path']:
            args.extend([opt, bdir + clude['path']])
        if clude['glob']:
            args.extend([opt, bdir + clude['glob']])
        if clude['regexp']:
            args.extend([opt + '-regexp', bdir + clude['regexp']])

    args.extend([cfg['user'] + '@' + cfg['host'] + '::' + bdir, cfg['dir']])
    debug('lbs: Run [' + ' '.join(args) + ']')
    ret = os.spawnvp(os.P_WAIT, args[0], args)
    if ret:
        raise Exception('rdiff-backup returned %d' % ret)

def do_server():
    if not os.path.exists(config_dir):
        raise Exception('lbs: config dir "' + config_dir + '" does not exist')

    ls = os.listdir(config_dir)
    for ent in ls:
        fn = config_dir + '/' + ent
        if not os.path.isfile(fn):
            continue
        if not ent.endswith('.cfg'):
            continue

        dom = xml.dom.minidom.parse(fn)
        try:
            cfg = parse_config(dom.documentElement)
        finally:
            dom.unlink()

        debug('lbs: Do server backup [' + cfg['id'] + ']')

        ssh = 'ssh -T'
        if cfg['key']:
            ssh += ' -i ' + cfg['key']
        ssh += ' -l ' + cfg['user'] + ' ' + cfg['host']
        debug('lbs: Run [' + ssh + ']')

        (cout, cin) = popen2.popen4(ssh)

        cfg_lines = open(fn).readlines()
        cin.write('CONFIG: %d\n' % (len(cfg_lines)))
        cin.writelines(cfg_lines)
        cin.flush()
        do_server_getanswer(cout)

        cin.write('BDIR\n')
        cin.flush()
        bdir = do_server_getanswer(cout)

        try:
            cin.write('SETUP ' + bdir + '\n')
            cin.flush()
            do_server_getanswer(cout)

            do_server_rdiff(cfg, bdir)
        finally:
            cin.write('CLEANUP ' + bdir + '\n')
            cin.flush()
            do_server_getanswer(cout)

        debug('lbs: Server backup [' + cfg['id'] + '] done')
    debug('lbs: Server backup done')

######################################################################
# Main routine
######################################################################

def usage():
    print 'usage: %s [options]' % (sys.argv[0])
    print
    print 'options:'
    print '-h, --help            show this help message and exit'
    print '-s, --server          launch in server mode (default)'
    print '-c, --client          launch in client mode'

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hsc', ['help', 'server', 'client'])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    mode = 'server'
    for o, a in opts:
        if o in ('-h', '--help'):
            usage()
            sys.exit()
        elif o in ('-s', '--server'):
            mode = 'server'
        elif o in ('-c', '--client'):
            mode = 'client'

    if mode == 'server':
        do_server()
    else:
        do_client()

if __name__ == '__main__':
    main()

# vim: et ts=8 sw=4 sts=4
