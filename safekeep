#!/usr/bin/python

import getopt, os, sys, re, traceback
import xml.dom.minidom
import popen2, tempfile

config_dir = './etc/labackup'

######################################################################
# Miscellaneous
######################################################################

def debug(msg):
    print msg
    sys.stdout.flush()
    pass

######################################################################
# Configuration file parser
######################################################################

def parse_dump(dump_el):
    type = dump_el.getAttribute('type')
    db = dump_el.getAttribute('db')
    user = dump_el.getAttribute('user')
    file = dump_el.getAttribute('file')
    cleanup = dump_el.getAttribute('cleanup')
    assert type and db and file
    return { 'type' : type, 'db' : db, 'user' : user,
             'file' : file, 'cleanup' : cleanup }

def parse_snap(snap_el):
    device = snap_el.getAttribute('device')
    assert device
    assert device.rfind('/') != -1 and not device.endswith('/')
    size = snap_el.getAttribute('size')
    assert size
    return { 'device' : device, 'size' : size }

def parse_clude(clude_el):
    path = clude_el.getAttribute('path')
    path = path.replace('*', '\*').replace('?', '\?')
    path = path.replace('[', '\[').replace(']', '\]')
    glob = clude_el.getAttribute('glob')
    regexp = clude_el.getAttribute('regexp')
    assert path or glob or regexp
    return { 'type' : clude_el.tagName, 'path' : path, 'glob' : glob, 'regexp' : regexp }

def parse_config(backup_el):
    assert backup_el.tagName == 'backup'
    id = backup_el.getAttribute('id')
    assert id

    host_el = backup_el.getElementsByTagName('host')
    host = host_el[0].getAttribute('name')
    if not host: host = 'localhost'
    user = host_el[0].getAttribute('user')
    if not user: user = 'root'
    key = host_el[0].getAttribute('key')
    key2 = host_el[0].getAttribute('key2')

    dir_el = backup_el.getElementsByTagName('dir')
    if len(dir_el) > 0:
        dir = dir_el[0].getAttribute('path')
    else: dir = None
    if not dir: dir = './' + id

    setup_el = backup_el.getElementsByTagName('setup')
    dumps = []
    snaps = []
    if len(setup_el) > 0:
        dump_els = setup_el[0].getElementsByTagName('dump')
        for dump_el in dump_els:
            dumps.append(parse_dump(dump_el))
        snap_els = setup_el[0].getElementsByTagName('snapshot')
        for snap_el in snap_els:
            snaps.append(parse_snap(snap_el))

    data_el = backup_el.getElementsByTagName('data')

    child_els = data_el[0].childNodes
    cludes = []
    for child_el in child_els:
        if child_el.nodeType != child_el.ELEMENT_NODE:
            continue
        if child_el.tagName not in ('include', 'exclude'):
            continue
        cludes.append(parse_clude(child_el))
    cludes.append({ 'type' : 'exclude', 'path' : '', 'glob' : '', 'regexp' : '.*' })

    return { 'id': id, 'host' : host, 'user' : user, 'key' : key, 'key2' : key2,
             'dir' : dir, 'dumps' : dumps, 'snaps' : snaps, 'cludes' : cludes}

######################################################################
# DB and SNAPSHOT support
#   setup methods can raise exception to signal errors
#   teardown methods must succeed and cleanup the state
######################################################################

def do_client_dbdump(cfg):
    debug('lbc: Doing DB dumps')
    for dump in cfg['dumps']:
        type = dump['type']
        if type in ('postgres', 'postgresql', 'pgsql'):
            args = ['pg_dump', '-f', dump['file']]
            if dump['user']:
                args.extend(['-U', dump['user']])
            args.append(dump['db'])
        elif type in ('mysql'):
            args = ['mysqldump', '-r', dump['file']]
            if dump['user']:
                args.extend(['-u', dump['user']])
            args.append(dump['db'])
        else:
            raise Exception('lbc: invalid database type: ' + type)
        ec = os.spawnvp(os.P_WAIT, args[0], args)
        if ec:
            raise Exception('lbc: can not dump the database: ' + dump['db'])

def do_client_dbdump_teardown(cfg):
    debug('lbc: Tear down DB dumps')
    for dump in cfg['dumps']:
        if dump['cleanup'] != 'true':
            continue
        try:
            os.remove(dump['file'])
        except:
            pass

def do_client_snap(cfg, bdir):
    debug('lbc: Doing FS snapshots')
    for snap in cfg['snaps']:
        snapdir = snap['device'][:snap['device'].rfind('/')]
        snapname = snap['device'][snap['device'].rfind('/') + 1 :] + '-snap'
        args = ['lvcreate', '-s', '-L', snap['size'], '-n', snapname, snap['device']]
        debug('lbc: [' + ' '.join(args) + ']')
        ec = os.spawnvp(os.P_WAIT, args[0], args)
        if ec:
            raise Exception('lbc: can not snapshot the device: ' + snap['device'])
        os.mkdir(bdir + '/' + snapname)
        args = ['mount', snapdir + '/' + snapname, bdir + '/' + snapname ]
        ec = os.spawnvp(os.P_WAIT, args[0], args)
        if ec:
            raise Exception('lbc: can not snapshot the device: ' + snap['device'])

def do_client_snap_teardown(cfg, bdir):
    debug('lbc: Tear down FS snapshots dumps')
    for snap in cfg['snaps']:
        snapdir = snap['device'][:snap['device'].rfind('/')]
        snapname = snap['device'][snap['device'].rfind('/') + 1 :] + '-snap'
        args = ['umount', bdir + '/' + snapname ]
        os.spawnvp(os.P_WAIT, args[0], args)
        try:
            os.rmdir(bdir + '/' + snapname)
        except:
            pass
        args = ['lvremove', snapdir + '/' + snapname ]
        os.spawnvp(os.P_WAIT, args[0], args)

######################################################################
# Client implementation
######################################################################

def do_client_config(cmd):
    cfgStr = ''

    cnt_str = cmd[cmd.index(':') + 1:].strip()
    for i in xrange(int(cnt_str)):
        line = sys.stdin.readline()
        if not line: raise Exception('Unexpected end of file')
        cfgStr += line

    dom = xml.dom.minidom.parseString(cfgStr)
    try:
        cfg = parse_config(dom.documentElement)
        print 'OK'
        sys.stdout.flush()
        return cfg
    finally:
        dom.unlink()

def do_client_setup(cfg):
    bdir = tempfile.mkdtemp()
    debug('lbc: Do setup of ' + cfg['host'] + ' in ' + bdir)
    do_client_dbdump(cfg)
    do_client_snap(cfg, bdir)
    print 'OK', bdir
    sys.stdout.flush()

def do_client_cleanup(cfg, bdir):
    debug('lbc: Do cleanup of ' + cfg['host'] + ' in ' + bdir)
    do_client_snap_teardown(cfg, bdir)
    do_client_dbdump_teardown(cfg)
    try:
        os.rmdir(bdir)
    except Exception, e:
        pass
    print 'OK'
    sys.stdout.flush()

def do_client():
    line = sys.stdin.readline()
    if line.startswith('CONFIG'):
        cfg = do_client_config(line)
    else:
        raise Exception('Unknown command: ' + line)

    line = sys.stdin.readline()
    if line.startswith('SETUP'):
        do_client_setup(cfg)
    elif line.startswith('CLEANUP'):
        do_client_cleanup(cfg, line[7:].strip())
    else:
        raise Exception('Unknown command: ' + line)

######################################################################
# Server implementation
######################################################################

def do_server_openconn(cfg):
    ssh = 'ssh -T'
    if cfg['key']:
        ssh += ' -i ' + cfg['key']
    ssh += ' -l ' + cfg['user'] + ' ' + cfg['host']

    debug('lbs: ssh=' + ssh)
    (cout, cin) = popen2.popen4(ssh)
    return (cout, cin)

def do_server_getanswer(cout):
    while True:
        line = cout.readline()
        if line.startswith('OK'):
            return line[2:-1].strip()
        elif line.startswith('ERROR'):
            # read full traceback from client
            line = line[5:] + cout.read()
            raise Exception(line)
        elif not line:
            raise Exception('client died unexpectedly')
        else:
            debug('lbs: ' + line[:-1])

def do_server_sendconfig(cout, cin, fn):
    cfg_lines = open(fn).readlines()
    cin.write('CONFIG: %d\n' % (len(cfg_lines)))
    cin.writelines(cfg_lines)
    cin.flush()
    do_server_getanswer(cout)

def do_server_setup(cfg, fn):
    debug('lbs: Do setup of ' + cfg['host'])

    (cout, cin) = do_server_openconn(cfg)

    do_server_sendconfig(cout, cin, fn)

    cin.write('SETUP\n')
    cin.flush()
    return do_server_getanswer(cout)

def do_server_rdiff(cfg):
    args = ['rdiff-backup']

    schema = 'ssh -C'
    if cfg['key2']:
        schema += ' -i ' + cfg['key2']
    schema += ' %s rdiff-backup --server'
    args.extend(['--remote-schema', schema])

    #args.extend([ '-v', '6'])
    for clude in cfg['cludes']:
        opt = '--' + clude['type']
        if clude['path']:
            args.extend([opt, clude['path']])
        if clude['glob']:
            args.extend([opt, clude['glob']])
        if clude['regexp']:
            args.extend([opt + '-regexp', clude['regexp']])

    args.extend([cfg['user'] + '@' + cfg['host'] + '::/', cfg['dir']])
    debug('lbs: Do rdiff-backup [' + ' '.join(args) + ']')
    ret = os.spawnvp(os.P_WAIT, args[0], args)
    if ret:
        raise Exception('rdiff-backup returned %d' % ret)

def do_server_cleanup(cfg, fn, bdir):
    debug('lbs: Do cleanup of ' + cfg['host'] + ' in ' + bdir)

    (cout, cin) = do_server_openconn(cfg)

    do_server_sendconfig(cout, cin, fn)

    cin.write('CLEANUP ' + bdir + '\n')
    cin.flush()
    do_server_getanswer(cout)

def do_server():
    if not os.path.exists(config_dir):
        raise Exception('lbs: config dir "' + config_dir + '" does not exist')

    ls = os.listdir(config_dir)
    for ent in ls:
        fn = config_dir + '/' + ent
        if not os.path.isfile(fn):
            continue
        if not ent.endswith('.cfg'):
            continue

        dom = xml.dom.minidom.parse(fn)
        try:
            cfg = parse_config(dom.documentElement)
        finally:
            dom.unlink()

        debug('lbs: Do server backup [' + cfg['id'] + ']')

        bdir = ''
        try:
            bdir = do_server_setup(cfg, fn)

            do_server_rdiff(cfg)
        finally:
            do_server_cleanup(cfg, fn, bdir)

        debug('lbs: Server backup [' + cfg['id'] + '] done')
    debug('lbs: Server backup done')

######################################################################
# Main routine
######################################################################

def usage():
    print 'usage: %s [options]' % (sys.argv[0])
    print
    print 'options:'
    print '-h, --help            show this help message and exit'
    print '-s, --server          launch in server mode (default)'
    print '-c, --client          launch in client mode'

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hsc', ['help', 'server', 'client'])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    mode = 'server'
    for o, a in opts:
        if o in ('-h', '--help'):
            usage()
            sys.exit()
        elif o in ('-s', '--server'):
            mode = 'server'
        elif o in ('-c', '--client'):
            mode = 'client'

    try:
        if mode == 'server':
            do_server()
        else:
            do_client()
    except Exception, e:
        if (mode == 'client'):
            print 'ERROR',
        traceback.print_exc(file=sys.stdout)
        sys.stdout.flush()
        sys.exit(1)

if __name__ == '__main__':
    main()

# vim: et ts=8 sw=4 sts=4
