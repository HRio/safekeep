#!/usr/bin/python

import getopt, os, sys, re, traceback
import xml.dom.minidom
import popen2, tempfile

config_dir = './etc/labackup'
rdiff_sem = '/tmp/rdiff_sem'
lbc_sem = '/tmp/lbc_sem'
temp_dir = ''

######################################################################
# Miscellaneous
######################################################################

def log(msg):
    print msg
    sys.stderr.flush()
    pass

######################################################################
# Configuration file parser
######################################################################

def parse_dump(dump_el):
    type = dump_el.getAttribute('type')
    db = dump_el.getAttribute('db')
    user = dump_el.getAttribute('user')
    file = dump_el.getAttribute('file')
    cleanup = dump_el.getAttribute('cleanup')
    assert type and db and file
    return { 'type' : type, 'db' : db, 'user' : user,
	     'file' : file, 'cleanup' : cleanup }

def parse_snap(snap_el):
    device = snap_el.getAttribute('device')
    assert device
    assert device.rfind('/') != -1 and not device.endswith('/')
    size = snap_el.getAttribute('size')
    assert size
    return { 'device' : device, 'size' : size }

def parse_clude(clude_el):
    path = clude_el.getAttribute('path')
    path = path.replace('*', '\*').replace('?', '\?')
    path = path.replace('[', '\[').replace(']', '\]')
    glob = clude_el.getAttribute('glob')
    regexp = clude_el.getAttribute('regexp')
    assert path or glob or regexp
    return { 'type' : clude_el.tagName, 'path' : path, 'glob' : glob, 'regexp' : regexp }

def parse_config(backup_el):
    assert backup_el.tagName == 'backup'
    id = backup_el.getAttribute('id')
    assert id

    host_el = backup_el.getElementsByTagName('host')
    host = host_el[0].getAttribute('name')
    if not host: host = 'localhost'
    user = host_el[0].getAttribute('user')
    if not user: user = 'root'

    dir_el = backup_el.getElementsByTagName('dir')
    dir = dir_el[0].getAttribute('path')
    if not dir: dir = './' + id

    setup_el = backup_el.getElementsByTagName('setup')
    dumps = []
    snaps = []
    if len(setup_el) > 0:
        dump_els = setup_el[0].getElementsByTagName('dump')
        for dump_el in dump_els:
            dumps.append(parse_dump(dump_el))
        snap_els = setup_el[0].getElementsByTagName('snapshot')
        for snap_el in snap_els:
            snaps.append(parse_snap(snap_el))

    data_el = backup_el.getElementsByTagName('data')

    child_els = data_el[0].childNodes
    cludes = []
    for child_el in child_els:
	if child_el.nodeType != child_el.ELEMENT_NODE:
	    continue
	if child_el.tagName not in ('include', 'exclude'):
	    continue
	cludes.append(parse_clude(child_el))
    cludes.append({ 'type' : 'exclude', 'path' : '', 'glob' : '', 'regexp' : '.*' })

    return { 'id': id, 'host' : host, 'user' : user, 'dir' : dir,
	     'dumps' : dumps, 'snaps' : snaps, 'cludes' : cludes}

######################################################################
# DB and SNAPSHOT support
#   setup methods can raise exception to signal errors
#   teardown methods must succeed and cleanup the state
######################################################################

def do_client_dbdump(cfg):
    log('lbc: Doing DB dumps')
    for dump in cfg['dumps']:
	type = dump['type']
	if type in ('postgres', 'postgresql', 'pgsql'):
	    args = ['pg_dump', '-f', dump['file']]
	    if dump['user']:
		args.extend(['-U', dump['user']])
	    args.append(dump['db'])
	elif type in ('mysql'):
	    args = ['mysqldump', '-r', dump['file']]
	    if dump['user']:
		args.extend(['-u', dump['user']])
	    args.append(dump['db'])
	else:
	    raise Exception('lbc: invalid database type: ' + type)
	ec = os.spawnvp(os.P_WAIT, args[0], args)
	if ec:
	    raise Exception('lbc: can not dump the database: ' + dump['db'])

def do_client_dbdump_teardown(cfg):
    log('lbc: Tear down DB dumps')
    for dump in cfg['dumps']:
	if dump['cleanup'] != 'true':
	    continue
	try:
	    os.remove(dump['file'])
	except:
	    pass

def do_client_snap(cfg):
    log('lbc: Doing FS snapshots')
    global temp_dir
    temp_dir = tempfile.mkdtemp()
    for snap in cfg['snaps']:
	snapdir = snap['device'][:snap['device'].rfind('/')]
	snapname = snap['device'][snap['device'].rfind('/') + 1 :] + '-snap'
	args = ['lvcreate', '-s', '-L', snap['size'], '-n', snapname, snap['device']]
	log('lbc: [' + ' '.join(args) + ']')
	ec = os.spawnvp(os.P_WAIT, args[0], args)
	if ec:
	    raise Exception('lbc: can not snapshot the device: ' + snap['device'])
	os.mkdir(temp_dir + '/' + snapname)
	args = ['mount', snapdir + '/' + snapname, temp_dir + '/' + snapname ]
	ec = os.spawnvp(os.P_WAIT, args[0], args)
	if ec:
	    raise Exception('lbc: can not snapshot the device: ' + snap['device'])

def do_client_snap_teardown(cfg):
    log('lbc: Tear down FS snapshots dumps')
    for snap in cfg['snaps']:
	snapdir = snap['device'][:snap['device'].rfind('/')]
	snapname = snap['device'][snap['device'].rfind('/') + 1 :] + '-snap'
	args = ['umount', temp_dir + '/' + snapname ]
	os.spawnvp(os.P_WAIT, args[0], args)
	try:
	    os.rmdir(temp_dir + '/' + snapname)
	except:
	    pass
	args = ['lvremove', snapdir + '/' + snapname ]
	os.spawnvp(os.P_WAIT, args[0], args)
    try:
	os.rmdir(temp_dir)
    except Exception, e:
	pass

######################################################################
# Client / server implementation
######################################################################

def do_client_rdiff():
    log('lbc: Doing rdiff-backup --server')
    args = [ 'rdiff-backup', '--server' ]
    os.execvp(args[0], args)
    print 'ERROR'
    sys.exit(1)

def do_server_rdiff(cfg):
    args = ['rdiff-backup']
    #args.extend([ '-v', '6'])
    for clude in cfg['cludes']:
	opt = '--' + clude['type']
	if clude['path']:
	    args.extend([opt, clude['path']])
	if clude['glob']:
	    args.extend([opt, clude['glob']])
	if clude['regexp']:
	    args.extend([opt + '-regexp', clude['regexp']])

    args.extend([cfg['user'] + '@' + cfg['host'] + '::/', cfg['dir']])
    log('lbs: Doing rdiff-backup [' + ' '.join(args) + ']')
    ret = os.spawnvp(os.P_WAIT, args[0], args)
    if ret:
	raise Exception('rdiff-backup returned %d' % ret)

def do_client():
    if os.path.exists(rdiff_sem):
	try:
	    os.remove(rdiff_sem)
	except Exception, e:
	    print 'ERROR: ', e
	    sys.exit(1)
	do_client_rdiff()
	# no return

    # read config file from server
    line = ''
    cfgStr = ''
    while line.find('</backup>') == -1:
	line = sys.stdin.readline()
	if not line:
	    log('lbc: Unexpected end of file')
	    sys.exit(1)
	cfgStr += line

    # parse it
    try:
	dom = xml.dom.minidom.parseString(cfgStr)
	cfg = parse_config(dom.documentElement)
	dom.unlink()
    except Exception, e:
	print 'ERROR: ', e
	sys.exit(1)

    log('lbc: Do backup of ' + cfg['host'])

    # prepare for backup
    try:
	do_client_dbdump(cfg)
    except Exception, e:
	print 'ERROR:', e
	do_client_dbdump_teardown(cfg)
	sys.exit(1)

    try:
	do_client_snap(cfg)
    except Exception, e:
	print 'ERROR:', e
	do_client_dbdump_teardown(cfg)
	do_client_snap_teardown(cfg)
	sys.exit(1)

    # go !
    lock = open(rdiff_sem, 'w')
    lock.close()
    print 'READY'
    sys.stdout.flush()

    # wait for rdiff-backup to end
    while line.find('CLEANUP') == -1:
	line = sys.stdin.readline()
	if not line:
	    print 'ERROR: Unexpected end of file'
	    sys.stdout.flush()
	    break

    # tear down...
    if os.path.exists(rdiff_sem):
	os.remove(rdiff_sem)

    do_client_snap_teardown(cfg)
    do_client_dbdump_teardown(cfg)

    print 'DONE'
    sys.exit(0)

def do_server():
    if not os.path.exists(config_dir):
	print 'lbs: config dir', config_dir, 'does not exist'
	sys.exit(1)

    ls = os.listdir(config_dir)
    for ent in ls:
	fn = config_dir + '/' + ent
	if not os.path.isfile(fn):
	    continue
	if not ent.endswith('.cfg'):
	    continue

	try:
	    dom = xml.dom.minidom.parse(fn)
	    cfg = parse_config(dom.documentElement)
	    dom.unlink()
	except Exception, e:
	    traceback.print_exc()
	    print 'lbs: config file error:', e
	    sys.exit(1)

	log('lbs: Do server backup [' + cfg['id'] + ']')
	(cout, cin) = popen2.popen4('ssh -T ' + cfg['user'] + '@' + cfg['host'])
	cin.write(open(fn).read())
	cin.flush()
	retcode = 0
	while True:
	    line = cout.readline()
	    if line.startswith('READY'):
		try:
		    do_server_rdiff(cfg)
		except Exception, e:
		    traceback.print_exc()
		    print 'lbs: Error in (server side) rdiff-backup: ', e
		    retcode = 1
		cin.write('CLEANUP\n')
		cin.flush()
	    elif line.startswith('DONE'):
		log('lbs: Client successfully ended')
		break
	    elif line.startswith('ERROR'):
		print 'lbs: Client error:', line
		retcode = 1
		break
	    elif not line:
		print 'lbs: Client died unexpectedly'
		retcode = 1
		break
	    else:
		print 'lbs: client says: ' + line[:-1]
	if retcode:
	    sys.exit(retcode)
	log('lbs: Server backup [' + cfg['id'] + '] done')
    log('lbs: Server backup done')

######################################################################
# Main routine
######################################################################

def usage():
    print 'usage: %s [options]' % (sys.argv[0])
    print
    print 'options:'
    print '-h, --help		 show this help message and exit'
    print '-s, --server		 launch in server mode (default)'
    print '-c, --client		 launch in client mode'

def main():
    try:
	opts, args = getopt.getopt(sys.argv[1:], 'hsc', ['help', 'server', 'client'])
    except getopt.GetoptError:
	usage()
	sys.exit(2)
    mode = 'server'
    for o, a in opts:
	if o in ('-h', '--help'):
	    usage()
	    sys.exit()
	elif o in ('-s', '--server'):
	    mode = 'server'
	elif o in ('-c', '--client'):
	    mode = 'client'
    if mode == 'server':
	do_server()
    else:
	do_client()

if __name__ == '__main__':
    main()

# vim: ts=8 sw=4 sts=4
