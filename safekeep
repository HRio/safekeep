#!/usr/bin/python

import getopt, os, os.path, sys, re
import commands, tempfile, traceback
import xml.dom.minidom
import socket, smtplib

config_dir = '/etc/labackup'
config_ext = '.cfg'
logbuf = []
is_client = False
verbosity_level = 1

VERSION = "0.1.0"
VEBOSITY_BY_CLASS = {'DBG': 3, 'INFO': 2, 'WARN': 1, 'ERR': 0}

######################################################################
# Miscellaneous support functions
######################################################################

def send(msg):
    print msg
    sys.stdout.flush()

def log(msg, cls=None):
    global logbuf
    if cls: 
        if is_client: cls = cls.lower()
        msg = '%s: %s' % (cls, msg)
    else:
        for c in VEBOSITY_BY_CLASS.keys():
            if msg.startswith(c + ': '):
                cls = c
                break
        else:
            cls = 'UNK'

    cutoff = VEBOSITY_BY_CLASS.get(cls.upper())
    if cutoff is None: cutoff = 3
    if is_client or verbosity_level >= cutoff:
        logbuf += msg
        print msg
        sys.stdout.flush()

def info_file(file):
    info('## File: ' + file)
    fin = open(file, 'r')
    try:
        for line in fin.readlines():
            info(line.rstrip())
    finally:
        fin.close()

def debug(msg):
    log(msg, 'DBG')

def info(msg):
    log(msg, 'INFO')

def warn(msg):
    log(msg, 'WARN')

def error(msg):
    log(msg, 'ERR')

def spawn(args):
    debug('Run [' + ' '.join(args) + ']')
    return os.spawnvp(os.P_WAIT, args[0], args)

def send_notification(email, smtp):
    global logbuf
    hostname = socket.gethostname()
    msg = 'From: LaBackup@' + hostname + \
          '\r\nTo: ' + ', '.join(email) + \
          '\r\nSubject: LaBackup results on ' + hostname + \
          '\r\n\r\n' + '\n'.join(logbuf)
    server = smtplib.SMTP(smtp)
    server.sendmail('LaBackup@' + hostname, email, msg)
    server.quit()

def is_temp_root(dir):
    return dir != '/'

######################################################################
# Configuration file parser
######################################################################

class ConfigException (Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def parse_dump(dump_el):
    type = dump_el.getAttribute('type')
    if not type:
        raise ConfigException('You need to specify the database type')
    if type not in ('postgres', 'postgresql', 'pgsql', 'mysql'):
        raise ConfigException('Invalid database type: ' + type)
    db = dump_el.getAttribute('db')
    user = dump_el.getAttribute('user')
    dbuser = dump_el.getAttribute('dbuser')
    file = dump_el.getAttribute('file')
    if not file:
        raise ConfigException('You need to specify where the database should be dumped')
    cleanup = dump_el.getAttribute('cleanup')
    return { 'type' : type, 'db' : db, 'user' : user, 'dbuser' : dbuser,
             'file' : file, 'cleanup' : cleanup }

def parse_snap(snap_el):
    device = snap_el.getAttribute('device')
    if not device:
        raise ConfigException('Please specify the device to be snapshot')
    if device.rfind('/') == -1 or device.endswith('/'):
        raise ConfigException('The device name seems incorrect: ' + device)
    size = snap_el.getAttribute('size')
    if not size:
        raise ConfigException('Please specify the size for the snapshot')
    return { 'device' : device, 'size' : size }

def parse_clude(clude_el):
    path = clude_el.getAttribute('path')
    path = path.replace('*', '\*').replace('?', '\?')
    path = path.replace('[', '\[').replace(']', '\]')
    glob = clude_el.getAttribute('glob')
    regexp = clude_el.getAttribute('regexp')
    if not path and not glob and not regexp:
        raise ConfigException('Empty ' + clude_el.tagName)
    return { 'type' : clude_el.tagName, 'path' : path, 'glob' : glob, 'regexp' : regexp }

def parse_config(backup_el, filename):
    if backup_el.tagName != 'backup':
        raise ConfigException('Invalid config file, the top level element must be <backup>')
    id = backup_el.getAttribute('id')
    if not id: id = filename

    host_el = backup_el.getElementsByTagName('host')
    if host_el:
        host = host_el[0].getAttribute('name')
        user = host_el[0].getAttribute('user')
        key_ctrl = host_el[0].getAttribute('key-ctrl')
        key_data = host_el[0].getAttribute('key-data')
    else:
        host = user = key_ctrl = key_data = None
    if host and key_ctrl is None:
        key_ctrl = os.path.join(os.environ['HOME'], '.ssh', 'labackup_server_ctrl_key')
    if host and key_data is None:
        key_data = os.path.join(os.environ['HOME'], '.ssh', 'labackup_server_data_key')

    repo_el = backup_el.getElementsByTagName('repo')
    dir = None
    retention = None
    if len(repo_el) == 1:
        dir = repo_el[0].getAttribute('path')
        retention = repo_el[0].getAttribute('retention')
    elif len(repo_el) > 1:
        raise ConfigException('Can not have more than a repo element')
    if not dir: dir = id

    setup_el = backup_el.getElementsByTagName('setup')
    dumps = []
    snaps = []
    if len(setup_el) > 0:
        dump_els = setup_el[0].getElementsByTagName('dump')
        for dump_el in dump_els:
            dumps.append(parse_dump(dump_el))
        snap_els = setup_el[0].getElementsByTagName('snapshot')
        for snap_el in snap_els:
            snaps.append(parse_snap(snap_el))

    data_el = backup_el.getElementsByTagName('data')

    child_els = data_el[0].childNodes
    cludes = []
    for child_el in child_els:
        if child_el.nodeType != child_el.ELEMENT_NODE:
            continue
        if child_el.tagName not in ('include', 'exclude'):
            continue
        cludes.append(parse_clude(child_el))
    cludes.append({ 'type' : 'exclude', 'path' : '', 'glob' : '', 'regexp' : '.*' })

    return { 'id': id, 'host' : host, 'user' : user, 'key-ctrl' : key_ctrl, 'key-data' : key_data,
             'dir' : dir, 'retention' : retention, 'dumps' : dumps, 'snaps' : snaps, 
             'cludes' : cludes}

def parse_locs(cfglocs):
    cfgfiles = []
    for cfg in cfglocs:
        if os.path.isdir(cfg):
            for ent in os.listdir(cfg):
                if not ent.endswith(config_ext):
                    continue
                filepath = os.path.join(cfg, ent)
                if not os.path.isfile(filepath):
                    continue
                cfgfiles.append(filepath)
        elif os.path.isfile(cfg):
            cfgfiles.append(cfg)
        else:
            print >> sys.stderr, 'Inaccessible configuration, ignoring:', cfg

    cfgs = []
    for filepath in cfgfiles:
        filename = os.path.splitext(os.path.basename(filepath))[0]

        cfg_file = open(filepath)
        cfg_str = cfg_file.read().strip()
        cfg_file.close()

        dom = xml.dom.minidom.parseString(cfg_str)
        try:
            cfg = parse_config(dom.documentElement, filename)
        finally:
            dom.unlink()
        cfg['text'] = cfg_str
        cfgs.append(cfg)

    return cfgs

######################################################################
# DB and SNAPSHOT support
#   setup methods can raise exception to signal errors
#   teardown methods must succeed and cleanup the state
######################################################################

def do_client_dbdump(cfg):
    debug('Doing DB dumps')
    for dump in cfg['dumps']:
        type = dump['type']
        if type in ('postgres', 'postgresql', 'pgsql'):
            if dump['db']:
                args = ['pg_dump']
            else:
                args = ['pg_dumpall']
            if dump['dbuser']:
                args.extend(['-U', dump['dbuser']])
            if dump['db']:
                args.append(dump['db'])
        elif type in ('mysql'):
            args = ['mysqldump']
            if dump['dbuser']:
                args.extend(['-u', dump['dbuser']])
            if dump['db']:
                args.append(dump['db'])
            else:
                args.append('-A')
        else:
            warn('Invalid database type: ' + type)
            continue
        if dump['user']:
            cmd = ' '.join([commands.mkarg(arg) for arg in args])
            args = [ 'su', '-c', cmd, '-', dump['user'] ]
        cmd = ' '.join([commands.mkarg(arg) for arg in args])
        cmd = '%s > %s' % (cmd, commands.mkarg(dump['file']))
        debug('Run [' + cmd + ']')
        ec = os.system(cmd)
        if ec:
            warn('Can not dump the database: ' + dump['db'])

def do_client_dbdump_teardown(cfg):
    debug('Tear down DB dumps')
    for dump in cfg['dumps']:
        if dump['cleanup'] != 'true':
            continue
        try:
            os.remove(dump['file'])
        except Exception, e:
            warn('Unable to remove dump file: %s for database %s because: %s' %
                 (dump['file'], dump['db'], e))

def gather_lvm_information(device):
    device = device.replace('/mapper','').replace('-','/')
    (group, volume) = device.split('/')[-2:]
    (cin, cout) = os.popen4('mount')
    lines = cout.readlines()
    cout.close()
    cin.close()
    for line in lines:
        if line.startswith('/dev/mapper/' + group + '-' + volume + ' '):
            return (group, volume, line.split(' ')[2], line.split(' ')[4])
        elif line.startswith('/dev/' + group + '/' + volume + ' '):
            return (group, volume, line.split(' ')[2], line.split(' ')[4])
    return (None, None, None, None)

def gather_snap_information(device, bdir):
    (group, volume, mp, mt) = gather_lvm_information(device)
    if not mp: return (None, None, None, None)
    lvmdev =  os.path.join('/dev', group, volume)
    if bdir[-1] == '/': bdir = bdir[:-1]
    snapname = '%s_snap_%s' % (volume, os.path.basename(bdir))
    snapdev = os.path.join('/dev', group, snapname)
    if os.path.isabs(mp[0]): mp = mp[1:]
    return (lvmdev, snapdev, os.path.join(bdir, mp), mt)

def do_client_snap(cfg, bdir):
    assert is_temp_root(bdir)
    debug('Doing FS snapshots')
    for snap in cfg['snaps']:
        device = snap['device']
        (lvmdev, snapdev, snapmnt, snaptyp) = gather_snap_information(device, bdir)
        if not snapmnt:
            warn('Cannot find the mountpoint for: ' + device)
            continue
        args = ['lvcreate', '--snapshot', '--size', snap['size'],
                '--name', os.path.basename(snapdev), lvmdev]
        ec = spawn(args)
        if ec:
            warn('Can not snapshot the device: ' + device)
            continue
        # no need to mkdir since the mountpoint already exists
        args = ['mount', '-t', snaptyp, snapdev, snapmnt]
        ec = spawn(args)
        if ec:
            warn('Can not mount the snapshot: ' + device)
            ret = spawn(['lvremove', '--force', snapdev])
            if ret:
                warn('Can not tear down snapshot: ' + device)

def do_client_snap_teardown(cfg, bdir):
    assert is_temp_root(bdir)
    debug('Tear down FS snapshots dumps')
    for snap in cfg['snaps']:
        device = snap['device']
        (lvmdev, snapdev, snapmnt, snaptyp) = gather_snap_information(device, bdir)
        if not snapmnt:
            warn('Can not find the mountpoint for: ' + device)
            continue
        ret = spawn(['umount', snapmnt])
        if ret:
            warn('umount %s returned %s' % (snapmnt, ret))
        ret = spawn(['lvremove', '--force', snapdev])
        if ret:
            warn('Can not tear down snapshot: ' + device)

######################################################################
# Client implementation
######################################################################

def do_client_config(cmd):
    cfgStr = ''

    cnt_str = cmd[cmd.index(':') + 1:].strip()
    for i in xrange(int(cnt_str)):
        line = sys.stdin.readline()
        if not line: raise ConfigException('Unexpected end of file')
        cfgStr += line

    dom = xml.dom.minidom.parseString(cfgStr)
    try:
        return parse_config(dom.documentElement, None)
    finally:
        dom.unlink()

def do_client_setup(cfg):
    debug('Do setup of %s' % cfg['host'])

    do_client_dbdump(cfg)

    if len(cfg['snaps']) > 0:
        bdir = tempfile.mkdtemp("", "lbc")
        ret = spawn(['mount', '--rbind', '/', bdir])
        if ret:
            warn('mount --rbind failed with %d, snapshotting will be disabled' % ret)
            try:
                os.rmdir(bdir)
            except Exception, e:
                warn('Failed to remove: ' + bdir)
            bdir = '/'
        else:
            do_client_snap(cfg, bdir)
    else:
        bdir = '/'
    debug('Working root is %s' % bdir)

    return bdir

def do_client_cleanup(cfg, bdir):
    debug('Do cleanup of %s in %s' % (cfg['host'], bdir))
    if is_temp_root(bdir): 
        do_client_snap_teardown(cfg, bdir)

        ret = spawn(['umount', '-l', bdir])
        if ret:
            warn('Failed to unmount: ' + bdir)
        else:
            try:
                os.rmdir(bdir)
            except Exception, e:
                warn('Unable to remove: ' + bdir)

    do_client_dbdump_teardown(cfg)

def do_client():
    debug("Do client main loop")
    should_cleanup = True
    bdir = '/'
    try:
        while True:
            try:
                line = sys.stdin.readline()
                if line.startswith('CONFIG'):
                    cfg = do_client_config(line)
                    send('OK')
                elif line.startswith('SETUP'):
                    bdir = do_client_setup(cfg)
                    send('OK ' + bdir)
                elif line.startswith('CLEANUP'):
                    dir = line[7:].strip()
                    if dir == bdir: should_cleanup = False
                    do_client_cleanup(cfg, dir)
                    send('OK')
                elif not line:
                    break
                else:
                    send('ERROR Unknown command: ' + line)
                    break
            except Exception, e:
                traceback.print_exc(file=sys.stdout)
                send('ERROR ' + e)
    finally:
        if should_cleanup:
            do_client_cleanup(cfg, bdir)


######################################################################
# Server implementation
######################################################################

def do_server_getanswer(cout):
    while True:
        line = cout.readline()
        if line.startswith('OK'):
            return line[2:-1].strip()
        elif line.startswith('ERROR'):
            raise Exception(line[5:])
        elif not line:
            raise Exception('client died unexpectedly')
        else:
            log(line[:-1])

def do_server_rdiff(cfg, bdir):
    args = ['rdiff-backup']

    if cfg['host']:
        schema = 'ssh -C'
        if cfg['key-data']:
            schema += ' -i ' + cfg['key-data']
        schema += ' %s rdiff-backup --server'
        args.extend(['--remote-schema', schema])

    #args.extend([ '-v', '6'])
    for clude in cfg['cludes']:
        opt = '--' + clude['type']
        if clude['path']:
            args.extend([opt, os.path.join(bdir, clude['path'])])
        if clude['glob']:
            args.extend([opt, os.path.join(bdir, clude['glob'])])
        if clude['regexp']:
            args.extend([opt + '-regexp', bdir + clude['regexp']])

    userhost = ''
    if cfg['host']:
        if cfg['user']: 
            userhost = cfg['user'] + '@'
        userhost += cfg['host']
    args.extend([userhost + '::' + bdir, cfg['dir']])
    ret = spawn(args)
    if ret:
        raise Exception('rdiff-backup returned %d' % ret)

def do_server_data_cleanup(cfg):
    args = ['rdiff-backup', '--remove-older-than', cfg['retention'], cfg['dir']]
    ret = spawn(args)
    if ret:
        warn('Failed to cleanup old data, please fix the problem manually')

def do_server(cfgs):
    debug("Do server main loop")
    for cfg in cfgs:
        if cfg['retention']:
            do_server_data_cleanup(cfg)

        debug('Do server backup [' + cfg['id'] + ']')

        if cfg['host']:
            cmd = 'ssh -T'
            if cfg['key-ctrl']:
                cmd += ' -i ' + cfg['key-ctrl']
            if cfg['user']:
                cmd += ' -l ' + cfg['user']
            cmd += ' ' + cfg['host']
        else:
            cmd = 'LaBackup --client'
        debug('Run [' + cmd + ']')
        (cin, cout) = os.popen4(cmd)

        cin.write('CONFIG: %d\n' % (len(cfg['text'].splitlines())))
        cin.write(cfg['text'] + '\n')
        cin.flush()
        do_server_getanswer(cout)

        cin.write('SETUP\n')
        cin.flush()
        bdir = do_server_getanswer(cout)

        rdiff_logdir = os.path.join(cfg['dir'], 'rdiff-backup-data')
        if os.path.isdir(rdiff_logdir):
            rdiff_logpre = os.listdir(rdiff_logdir)
        else:
            rdiff_logpre = []
    
        do_server_rdiff(cfg, bdir)

        if os.path.isdir(rdiff_logdir):
            info_file(os.path.join(rdiff_logdir, 'backup.log'))
            rdiff_logpost = os.listdir(rdiff_logdir)
            for lfn in rdiff_logpost:
                if lfn.startswith('session_statistics.') and lfn.endswith('.data') and lfn not in rdiff_logpre:
                    info_file(os.path.join(rdiff_logdir, lfn))
        else:
            warn('Log dir does not exist.')

        cin.write('CLEANUP %s\n' % bdir)
        cin.flush()
        do_server_getanswer(cout)

        debug('Server backup [' + cfg['id'] + '] done')

    debug('Server backup done')

def do_keys(cfgs, id, display):
    debug("Do server main loop")
    host = os.environ['HOSTNAME']
    for cfg in cfgs:
        if cfg['id'] != id: continue
        cmds = ['LaBackup --client', 'rdiff-backup --server --restrict-read-only /']
        keyfiles = [cfg.get('key-ctrl'), cfg.get('key-data')]
        for (cmd, keyfile) in zip(cmds, keyfiles):
            if keyfile:
                keyin = open(keyfile, 'r')
                key = keyin.read()
                keyin.close()
            else:
                key = 'NOT AVAILABLE'
            line = '"command=%s",from=%s,no-port-forwarding,no-X11-forwarding,no-pty %s' % (cmd, host, key)
            if display:
                print line
            else:
                # FIXME: append the line to the .ssh/authorized_keys on the client
                # echo "$line" | ssh $1 "umask 077; test -d .ssh || mkdir .ssh ; cat >> .ssh/authorized_keys" || exit 1
                pass
        break
    else:
        error('No client with id \'%s\'' % id)

######################################################################
# Main routine
######################################################################

def usage():
    print 'usage: %s <mode> [options]' % (sys.argv[0])
    print 'mode selection (pick one):'
    print '-s, --server        launch in server mode (default)'
    print '-c, --client        launch in client mode'
    print '-k, --keys          manage SSH keys'
    print '-h, --help          show this help message and exit'
    print '-V, --version       show the version number and exit'
    print
    print 'options:'
    print '-C, --cfg=FILE|DIR  use the given configuration file/directory'
    print '-e, --email=EMAIL   send results by email (can appear multiple times)'
    print '-m, --smtp=SMTP     SMTP server to use when sending mails (default: built-in SMTP)'
    print '--clientid=ID       manage the keys of client identified by ID (keys mode only)'
    print '--print             display the authorization keys (keys mode only)'
    print '-q, --quiet         decreases the verbosity level'
    print '-v, --verbose       increases the verbosity level'

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'C:e:hkm:scqvV', 
                                   ['cfg=', 'email=', 'help', 'smtp=', 'server', 'client', 'keys', 'clientid=', 'print', 'quiet', 'verbose', 'version'])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    mode = 'server'
    email = []
    smtp = ''
    cfglocs = []
    verbosity = 0
    clientid = None
    display = None
    for o, a in opts:
        if o in ('-C', '--cfg'):
            cfglocs.append(a)
        elif o in ('-e', '--email'):
            email.append(a)
        elif o in ('-h', '--help'):
            usage()
            sys.exit()
        elif o in ('-m', '--smtp'):
            smtp = a
        elif o in ('-s', '--server'):
            mode = 'server'
        elif o in ('-c', '--client'):
            mode = 'client'
        elif o in ('-k', '--keys'):
            mode = 'keys'
        elif o in ('--clientid', ):
            clientid = a
        elif o in ('--print', ):
            display = True
        elif o in ('-q', '--quiet'):
            verbosity -= 1
        elif o in ('-v', '--verbose'):
            verbosity += 1
        elif o in ('-V', '--version'):
            print 'LaBackup', VERSION
            return

    if len(cfglocs) == 0:
        cfglocs.append(config_dir)

    cfgs = parse_locs(cfglocs)
    try:
        global is_client, verbosity_level
        if mode == 'server':
            is_client = False
            verbosity_level = 1 + verbosity
            do_server(cfgs)
        elif mode == 'client':
            is_client = True
            verbosity_level = 3 + verbosity
            do_client()
        elif mode == 'keys':
            is_client = False
            verbosity_level = 1 + verbosity
            do_keys(cfgs, clientid, display)
        else:
            assert False, 'Unkown mode: ' + mode
    except Exception, ex:
        traceback.print_exc(file=sys.stdout)
        error('ERROR: %s' % ex)

    if email:
        send_notification(email, smtp)

if __name__ == '__main__':
    main()

# vim: et ts=8 sw=4 sts=4
